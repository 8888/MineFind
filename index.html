<html>
<head><title>Mine Find</title></head>
<body bgcolor="#ccddff">
	<canvas id="canvasElement" width="640" height="640"></canvas>
	<script type="text/javascript">
		'use strict';
		var canvas = document.getElementById("canvasElement");
		canvas.tabIndex = 0;
		canvas.focus();

		var canvas_width = canvas.width;
		var canvas_height = canvas.height;
		var canvas_bounds = canvas.getBoundingClientRect();
		var ctx = canvas.getContext("2d");

        var mouseX = null,
            mouseY = null;

        var State = null;
        var Game = null;
        var mine_count = 0;
        var board_width = 0;
        var board_height = 0;

        var border_width = 2;
        var display_divider = 10;
        var header_height = 40;
        var space_size = 20;

		function init() {
            class GameState {
                // State of the game
                constructor() {
                    this.new_game = 0b00000001;
                    this.game_over = 0b00010000;
                }
            }

            class Space {
                // Space on the gameboard
                constructor() {
                    this.has_mine = false;
                    this.clicked = false;
                    this.was_flagged = false;
                    this.adjacent_mines = 0;
                }
            }

            class GameLogic {
                // Main game logic
                constructor() {
                    this.board = null;
                    this.state = null;
                }

                create_board(mines, width, height) {
                    // Returns an array of a board of size width x height with a given number of mines
                    var board_length = width * height;
                    var board = []; // matrix of spaces. row x column
                    for (let r = 0; r < board_height; r++) { // add the spaces
                        let row = [];
                        for (let c = 0; c < board_width; c++) {
                            row.push(new Space);
                        }
                        board.push(row);
                    }
                    for (var m = 0; m < mines; m++) { // add the mines
                        let indexR = this.rng(0, board_height); // row to place the mine
                        let indexC = this.rng(0, board_width); // column to place the mine
                        if (board[indexR][indexC].has_mine) {
                           m--; // Can not add a mine twice, try a different space
                        } else {
                            board[indexR][indexC].has_mine = true;
                        }
                    }
                    for (let row = 0; row < board.length; row++) { // add the adjacent-mine counter
                        for (let col = 0; col < board[row].length; col++) {
                            if (!board[row][col].has_mine) { // spaces with mines do not show a number
                                let mines_near = 0;
                                let spaces_to_check = [];
                                spaces_to_check.push([row - 1, col - 1]); // top left
                                spaces_to_check.push([row - 1, col]); // top mid
                                spaces_to_check.push([row - 1, col + 1]); // top right
                                spaces_to_check.push([row, col - 1]); // mid left
                                spaces_to_check.push([row, col + 1]); // mid right
                                spaces_to_check.push([row + 1, col - 1]); // bot left
                                spaces_to_check.push([row + 1, col]); // bot mid
                                spaces_to_check.push([row + 1, col + 1]); // bot right
                                for (let s = 0; s < spaces_to_check.length; s++) {
                                    let spaceR = spaces_to_check[s][0]; // row
                                    let spaceC = spaces_to_check[s][1]; // col
                                    if (spaceR >= 0 && spaceR < board.length && spaceC >= 0 && spaceC < board[row].length) { // check for out of range
                                        if (board[spaceR][spaceC].has_mine) {
                                            mines_near++;
                                        }
                                    }
                                }
                                board[row][col].adjacent_mines = mines_near;
                            }
                        }
                    }
                    return board;
                }

                rng(min, max) {
                    // Returns a random integer between min(inclusive) and max(exclusive)
                    return Math.floor(Math.random() * (max - min)) + min;
                }

                new_game() {
                    this.board = this.create_board(mine_count, board_width, board_height);
                    this.state = State.new_game;
                }
            }

            mine_count = 10;
            board_width = 9;
            board_height = 9;
            State = new GameState();
            Game = new GameLogic();
            Game.new_game();

            // Tests -- Uncomment to run
            //Test.test_board(Game.board, board_width, board_height, mine_count);
		}

		// Handle User Input
		canvas.addEventListener("mousedown", function(event) {
			console.log("x: ", mouseX);
            console.log("y: ", mouseY);
		});
		canvas.addEventListener("mousemove", function(event) {
			mouseX = event.clientX - canvas_bounds.left;
			mouseY = event.clientY - canvas_bounds.top;
		});

		var gameDelta = null,
            frameCount = 0;
		function update(delta) {
			gameDelta = delta;
            frameCount++;
		}

        // Draw elements to the screen
		function display() {
			ctx.clearRect(0, 0, canvas_width, canvas_height);

            function draw_board() {
                let originX = canvas_bounds.left + 50;
                let originY = canvas_bounds.top + 50;
                let display_width = display_divider + (board_width * space_size) + display_divider;
                let display_height = display_divider + header_height + display_divider + (board_height * space_size) + display_divider;
                
                rect_with_border( // background
                    ctx,
                    originX,
                    originY,
                    display_width,
                    display_height,
                    "#ffffff", // white
                    "#777777", // dark gray
                    "#777777",
                    "#ffffff",
                    border_width,
                    true,
                    "#bfbfbf" // light gray
                );
                rect_with_border( // header borders
                    ctx, 
                    originX + display_divider - (border_width / 2), 
                    originY + display_divider, 
                    board_width * space_size + border_width, 
                    header_height, 
                    "#777777", 
                    "#ffffff", 
                    "#ffffff", 
                    "#777777", 
                    border_width, 
                    false
                );
                rect_with_border( // inner borders
                    ctx, 
                    originX + display_divider - (border_width / 2),
                    originY + display_divider + header_height + display_divider - (border_width / 2), 
                    board_width * space_size + border_width, 
                    board_height * space_size + border_width, 
                    "#777777", 
                    "#ffffff", 
                    "#ffffff", 
                    "#777777", 
                    border_width,
                    false
                );
                // spaces
                let space_originX = originX + display_divider;
                let space_originY = originY + display_divider + header_height + display_divider; // sets a 0,0 at the game board
                for (let row = 0; row < Game.board.length; row++) {
                    for (let col = 0; col < Game.board[row].length; col++) {
                        // draw the grid beheind the unclicked spaces
                        if (row === 0 && col > 0) { // row: only draw once when making the first row. col: dont draw on the border
                            ctx.beginPath() // verticle grid lines
                            ctx.strokeStyle = "#777777"; // dark gray
                            ctx.moveTo(space_originX + (col * space_size), space_originY);
                            ctx.lineTo(space_originX + (col * space_size), space_originY + (Game.board[row].length * space_size));
                            ctx.stroke();
                        }
                        if (col === 0 && row > 0) {
                            ctx.beginPath() // horizontal grid lines
                            ctx.strokeStyle = "#777777"; // dark gray
                            ctx.moveTo(space_originX, space_originY + (row * space_size));
                            ctx.lineTo(space_originX + (Game.board.length * space_size), space_originY + (row * space_size));
                            ctx.stroke();
                        }
                        // draw the individual spaces
                        if (Game.board[row][col].clicked) {
                            if (Game.board[row][col].has_mine) {
                                // draw a mine
                            } else if (Game.board[row][col].adjacent_mines > 0) {
                                // draw the number of mines
                            }
                        } else { // space was not clicked
                            rect_with_border( // background
                                ctx,
                                space_originX + (col * space_size),
                                space_originY + (row * space_size),
                                space_size,
                                space_size,
                                "#ffffff",
                                "#777777",
                                "#777777",
                                "#ffffff",
                                border_width,
                                false
                            );
                        }
                    }
                }
            }

            function rect_with_border(ctx, x, y, width, height, upper_color, right_color, lower_color, left_color, border_size, fill, fill_color) {
                if (fill) {
                    ctx.fillStyle = fill_color;
                    ctx.fillRect(x, y, width, height);
                }
                // upper border
                ctx.beginPath();
                ctx.strokeStyle = upper_color;
                ctx.moveTo(x, y + (border_size / 2));
                ctx.lineTo(x + width, y + (border_size / 2));
                ctx.stroke();
                // right border
                ctx.beginPath();
                ctx.strokeStyle = right_color;
                ctx.moveTo(x + width - (border_size / 2), y);
                ctx.lineTo(x + width - (border_size / 2), y + height);
                ctx.stroke();
                // lower border
                ctx.beginPath();
                ctx.strokeStyle = lower_color;
                ctx.moveTo(x + width, y + height - (border_size / 2));
                ctx.lineTo(x, y + height - (border_size / 2));
                ctx.stroke();
                // left border
                ctx.beginPath();
                ctx.strokeStyle = left_color;
                ctx.moveTo(x + (border_size / 2), y + height);
                ctx.lineTo(x + (border_size / 2), y);
                ctx.stroke();
            }

            draw_board();
		}

		window.onload = function() {
			init();
			var mainloop_updateLast = performance.now();
			(function mainLoop(nowTime) {
				update(nowTime - mainloop_updateLast);
				display();
				mainloop_updateLast = nowTime;
				requestAnimationFrame(mainLoop);
			})(performance.now());
		}
	</script>
    <script type="text/javascript" src="test/test.js"></script>
</body>
</html>