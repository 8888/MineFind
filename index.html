<html>
<head><title>Mine Find</title></head>
<body bgcolor="#24AF69">
	<canvas id="canvasElement" width="640" height="640" style="background-color: #F0F8FF;"></canvas>
	<script type="text/javascript">
		'use strict';
		var canvas = document.getElementById("canvasElement");
		canvas.tabIndex = 0;
		canvas.focus();

		var canvas_width = canvas.width;
		var canvas_height = canvas.height;
		var canvas_bounds = canvas.getBoundingClientRect();
		var ctx = canvas.getContext("2d");

        var mouseX = null,
            mouseY = null;

        var State = null;
        var Game = null;
        var mine_count = 0;
        var board_width = 0;
        var board_height = 0;

		function init() {
            class GameState {
                // State of the game
                constructor() {
                    this.new_game = 0b00000001;
                    this.game_over = 0b00010000;
                }
            }

            class Space {
                // Space on the gameboard
                constructor() {
                    this.has_mine = false;
                    this.clicked = false;
                    this.was_flagged = false;
                    this.adjacent_mines = 0;
                }
            }

            class Game {
                // Main game logic
                constructor() {
                    this.board = null;
                }

                create_board(mines, width, height) {
                    // Returns an array of a board of size width x height with a given number of mines
                    var board_length = width * height;
                    var board = [];
                    for (var s = 0; s < board_length; s++) { // add the spaces
                        board.push(new Space);
                    }
                    for (var m = 0; m < mines; m++) { // add the mines
                        let index = this.rng(0, board_length);
                        if (board[index].has_mine) {
                            m--; // Can not add a mine twice, try a different space
                        } else {
                            board[index].has_mine = true;
                        }
                    }
                    // add the adjacent mine counter
                    for (var x = 0; x < board_length; x++) { // TODO: This doesn't work properly, the last element of row 1 evaluates as adjacent to the first element of row 2. Ex index 8 and 9.
                        if (!board[x].has_mine) { // spaces with mines do not show a number
                            var mines_near = 0;
                            var spaces_to_check = []; // 8 possible spaces
                            spaces_to_check.push(x - board_width - 1); // top left
                            spaces_to_check.push(x - board_width); // top mid
                            spaces_to_check.push(x - board_width + 1); // top right
                            spaces_to_check.push(x - 1); // mid left
                            spaces_to_check.push(x + 1); // mid right
                            spaces_to_check.push(x + board_width - 1); // bot left
                            spaces_to_check.push(x + board_width); // bot mid
                            spaces_to_check.push(x + board_width + 1); // bot right
                            for (var oor = 0; oor < spaces_to_check.length; oor++) { // check for out of range of array
                                if (spaces_to_check[oor] < 0 || spaces_to_check[oor] >= board_length) {
                                    spaces_to_check.splice(oor, 1) // (index, number of elements to remove)
                                    oor -= 1;
                                }
                            }
                            for (var c = 0; c < spaces_to_check.length; c++) {
                                if (board[spaces_to_check[c]].has_mine) {
                                    mines_near += 1;
                                }
                            }
                            board[x].adjacent_mines = mines_near;
                        }
                    }
                    return board;
                }

                rng(min, max) {
                    // Returns a random integer between min(inclusive) and max(exclusive)
                    return Math.floor(Math.random() * (max - min)) + min;
                }

                new_game() {
                    this.board = this.create_board(mine_count, board_width, board_height);
                }
            }

            mine_count = 10;
            board_width = 9;
            board_height = 9;
            State = new GameState();
            Game = new Game();
            Game.new_game();

            // Tests -- Uncomment to run
            //Test.test_board(Game.board, board_width * board_height, mine_count);
		}

		//Handle User Input
		canvas.addEventListener("mousedown", function(event) {
			console.log("x: ", mouseX);
            console.log("y: ", mouseY);
		});
		canvas.addEventListener("mousemove", function(event) {
			mouseX = event.clientX - canvas_bounds.left;
			mouseY = event.clientY - canvas_bounds.top;
		});

		var gameDelta = null,
            frameCount = 0;
		function update(delta) {
			gameDelta = delta;
            frameCount++;
		}

		function display() {
			ctx.clearRect(0, 0, canvas_width, canvas_height);

            function draw_board(board) {

            }
		}

		window.onload = function() {
			init();
			var mainloop_updateLast = performance.now();
			(function mainLoop(nowTime) {
				update(nowTime - mainloop_updateLast);
				display();
				mainloop_updateLast = nowTime;
				requestAnimationFrame(mainLoop);
			})(performance.now());
		}
	</script>
    <script type="text/javascript" src="test/test.js"></script>
</body>
</html>